sort node

immutable constant skol_node : node

mutable constant x : int 
mutable relation loc0(node)
mutable relation loc1(node)

init x = 0 
init loc0(N)
init ~loc1(N)

transition step01(n: node)
	modifies x,loc0,loc1
  & loc0(n)
	& new(x) = x + 1  
  & new(loc1(N)) = (loc1(N) | N=n)
  & new(loc0(N)) = (loc0(N) & N != n)

transition step10(n: node)
	modifies x,loc0,loc1
  & loc1(n)
	& new(x) = x - 1  
  & new(loc0(N)) = (loc0(N) | N=n) 
  & new(loc1(N)) = (loc1(N) & N != n)

invariant loc0(N) | loc1(N)
invariant ~ (loc0(N) & loc1(N))
safety ~(loc1(skol_node) & x <= 0)

squeezer cutoff node 2

squeezer condition(z: node) =
  z != skol_node

squeezer update x(z: node) : int =
  if loc1(z)
      then
          x - 1
      else
          x

#Then the user writes the squeezer (that uses the special name sq_node)
#
# squeezer 
#   & new(loc0(N)) = loc0(N)
#   & new(loc1(N)) = loc0(N)
#   & if loc1(sq_node) 
#     then 
#        new(x) = x - 1
#     else 
#        new(x) = X
#
# maybe we will need also replacement conditions (not in this example)
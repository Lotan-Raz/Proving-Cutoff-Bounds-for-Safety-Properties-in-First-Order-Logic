#equalsum taking from the commutativity paper

sort thread
sort index

immutable constant skol_thread1 : thread
immutable constant skol_thread2 : thread

immutable relation leq(index,index)
axiom leq(X,Y) & leq(Y,Z) -> leq(X,Z)
axiom leq(X,Y) & leq(Y,X) -> X=Y 
axiom leq(X,Y) | leq(Y,X)
immutable constant min : index
immutable constant max : index
axiom leq(min,X) 
axiom leq(X,max)
immutable function succ(index) : index
axiom [succ_def] X!=max -> leq(X,succ(X)) & X!=succ(X) & forall Y. ( leq(X,Y) -> leq(succ(X),Y) ) 

immutable function array(index) : int  
mutable function sum(thread) : int
mutable function pointer(thread) : index
mutable relation terminated(thread)

init sum(T) = 0
init pointer(T) = min
init !terminated(T)

transition loop(t: thread)
  modifies sum,pointer,terminated
  & !terminated(t)
  & if (T = t)
    then & new(sum(T)) = sum(t) + array(pointer(t))
         & new(pointer(T)) = succ(pointer(t))
         & new(terminated(T)) = terminated(T) | (pointer(t) = max)
    else & new(sum(T)) = sum(T) 
         & new(pointer(T)) = pointer(T)
         & new(terminated(T)) = terminated(T) 

safety terminated(skol_thread1) & terminated(skol_thread2) -> sum(skol_thread1)=sum(skol_thread2)

cutoff sort thread

cutoff condition(z: thread) =
  z != skol_thread1 & z != skol_thread2 